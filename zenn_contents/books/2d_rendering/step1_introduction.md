---
title: "Step1_1: 実行基盤とメモリ管理レイヤの初期化(2Dレンダリング編)"
---

TODO: Introduction
- [x] 目的
- [x] 到達点
- [x] C言語を選んだ理由
- [x] ツール / 外部ライブラリの使用についての考え方
- [] Booksの構成とREADME.mdとの整合性
- [] 各ステップ詳細記事

この記事は、「C言語とGLFWで作るゲームエンジン開発記録」のファーストステップです。

ゲームエンジンと聞くと、リッチなグラフィックスを描く華やかなソフトウェアを思い浮かべるかもしれません。
しかしその裏側では、マテリアルやモデルデータの管理、メモリの確保と解放、
マウスやキーボードからのイベント処理など、多くの機能が連携して動いています。
このためゲームエンジンは複雑かつ大規模になりやすく、統一感ある設計と堅牢な基盤が欠かせません。

このファーストステップでは、統一感を持ってエンジンが持つ各機能を立ち上げていくことができるアプリケーションの土台を開発していきます。

なお、今後、様々な機能を開発していくことになりますが、開発過程においては、それぞれの機能をできるだけシンプルに保つことが重要です。
ゲームエンジンのように多くの機能が連携、相互作用して動くソフトウェアにおいて、各機能をシンプルに保つために、
各機能を完全に完成させてから次の機能を開発するのではなく、最小限の機能を実装し、それを足場にして次の機能を作る、
というアプローチを取ることにします。

このアプローチを取ることで、各機能に対する変更が多くなります。
そのため記事としては読みにくいところが出てくる可能性がありますが、
できるだけ分かりやすい説明になるようにしたいと思っています。

## 使用環境とツール選定

### 使用言語について

一般的に、ゲームエンジンはC++を用いて開発されることが多いですが、
今回はC言語を使用してゲームエンジンを開発していきます。

理由は、

1. ビルド時間がC++よりも高速で、RaspberryPi等の非力なコントローラでもビルドしやすいこと
2. C言語を使用することで、コードの統一感を持たせることがC++よりも容易であること

の2点です。特に2番目は重要です。
C++は言語体系が大きく、複数のプログラミングパラダイムを包含しています。
そのため、多様なスタイルでコーディングできる一方、プロジェクト全体として統一感を保つためには多くの配慮が必要になります。
一方、C言語はシンプルで、コード全体を一貫したスタイルで保ちやすいという利点があります。

ただ、C++ではなく、C言語を使用するデメリットも当然あり、

1. 型チェックがC++に比べて弱く、バグが紛れ込むリスクが高くなる
2. boostライブラリのようなリッチなライブラリ群が存在しない
3. STLコンテナのような汎用的で便利なデータ構造が利用できない

1番目、2番目は純粋なデメリットとなっていて、
1番目は、注意深くコーディングするしかなく、2番目は自前実装で補う必要があります。

一方、3番目については場合によってはデメリットにはなりません。
理由は、たとえばstd::vectorのようなコンテナは非常に便利ですが、
メモリ確保の仕組みを理解していないと必要以上のリソースを消費する可能性があります。

そのため、ゲームエンジン開発ではSTLコンテナを使わず、独自の軽量コンテナを実装するケースも少なくありません。
最小限の機能に絞ればC言語での実装も十分可能であり、大きなデメリットとはならないでしょう。
さらに、自前実装することで、データ構造、メモリ管理の仕組みを学ぶことができるという副次的な効果もあります。

以上の背景から今回はC言語を使用して開発していくことにします。

### ビルドツールについて

今回のゲームエンジン開発では、ビルドツールとして、makefileを使用したGNU makeと、シェルスクリプトのみを使用します。

一般的には CMake を使うケースが多いと思いますが、本連載では以下の理由から採用しません。

- **習得コストが高い**
  CMakeLists.txtの記述はライブラリごとに固有の方法が必要になる場合があり、マルチプラットフォーム対応やビルド条件の設定も複雑になりがちです。
- **バージョン依存のリスク**
  CMake自体や外部ライブラリのバージョン差異によって、ビルドが失敗する可能性があります。

一方で makefile にも基本的な文法の理解は必要ですが、ライブラリごとに異なる書き方を覚える必要はありません。
一度雛形を作ってしまえばプロジェクト間で容易に流用できますし、後のメンテナンスも CMakeLists.txt に比べてシンプルです。

### ライブラリについて

本連載で扱うゲームエンジンでは、マルチプラットフォーム対応を簡便に行うためにGLFWを使用します。

想定しているプラットフォームはLinux / macOS / FreeBSDで、Windows については未定です。
これらの環境ごとにイベント管理やウィンドウ生成を一から実装するのは非常に大きな労力となります。

本連載の主眼は、OpenGLを用いたレンダリングや、マテリアルなどのリソース管理、
形状データのジオメトリ管理の方法を学ぶことにあります。
そのため、GLFWを利用してOS依存の処理を抽象化することで、学習の焦点を本来の目的に集中できるようにします。

## Step1_1実装解説

以上が今回開発するゲームエンジンについての開発方針の説明です。
ここからは具体的にゲームエンジンの実装を進めていきます。

Step1_1では、「実行基盤とメモリ管理レイヤの初期化」の開発を行っていきます。

### アプリケーション土台作り

[アプリケーション土台作り](articles/zenn/step1_1_application_base.md)

### アプリケーションレイヤーの追加

[アプリケーションレイヤーの追加](articles/zenn/step1_2_application_layer.md)

### ベースレイヤーの追加

[ベースレイヤーの追加](articles/zenn/step1_3_base_layer.md)

### core/memoryレイヤーの追加(linear_allocator)

[core/memoryレイヤーの追加(linear_allocator)](articles/zenn/step1_4_core_memory_linear_allocator.md)

### core/memoryレイヤーの追加(memory_system)

[core/memoryレイヤーの追加(memory_system)](articles/zenn/step1_5_core_memory_system.md)

### Doxygenドキュメンテーション

[Doxygenドキュメンテーション](articles/zenn/step1_6_doxygen.md)
