---
title: "Step1: 実行基盤とメモリ管理レイヤの初期化(イントロダクション)"
free: true
---

※本記事は [全体イントロダクション](https://zenn.dev/chocolate_pie24/articles/c-glfw-game-engine-introduction)のBook1に対応しています。

この記事は、「C言語とGLFWで作るゲームエンジン開発記録」のファーストステップです。

ゲームエンジンと聞くと、リッチなグラフィックスを描く華やかなソフトウェアを思い浮かべるかもしれません。しかしその裏側では、マテリアルやモデルデータの管理、メモリの確保と解放、マウスやキーボードからのイベント処理など、多くの機能が連携して動いています。

このためゲームエンジンは複雑かつ大規模になりやすく、統一感ある設計と堅牢な基盤が欠かせません。

このファーストステップでは、統一感を持ってエンジンが持つ各機能を立ち上げていくことができるアプリケーションの土台を開発していきます。

今後、様々な機能を開発していくことになりますが、開発過程においては、それぞれの機能をできるだけシンプルに保つことが重要です。

ゲームエンジンは多くの機能が連携、相互作用して動きます。それぞれの機能をシンプルに保つために、各機能を完全に完成させてから次の機能を開発するのではなく、最小限の機能を実装し、それを足場にして次の機能を作る、というアプローチを取ることにします。

このアプローチを取ることで、各機能に対する変更が多くなります。そのため記事としては読みにくいところが出てくる可能性がありますが、できるだけ分かりやすい説明になるようにしたいと思っています。

## 使用環境とツール選定

### 使用言語について

一般的に、ゲームエンジンはC++を用いて開発されることが多いですが、今回はC言語を使用してゲームエンジンを開発していきます。

理由は、

1. ビルド時間がC++よりも高速で、RaspberryPi等の非力なコントローラでもビルドしやすい
2. C言語を使用することで、コードの統一感を持たせることがC++よりも容易である

の2点です。特に2番目は重要です。
C++は言語体系が大きく、複数のプログラミングパラダイムを包含しています。そのため、多様なスタイルでコーディングできる一方、プロジェクト全体として統一感を保つためには多くの配慮が必要になります。一方、C言語はシンプルで、コード全体を一貫したスタイルで保ちやすいという利点があります。

ただ、C++ではなく、C言語を使用するデメリットも当然あり、

1. 型チェックがC++に比べて弱く、バグが紛れ込むリスクが高くなる
2. boostライブラリのようなリッチなライブラリ群が存在しない
3. STLコンテナのような汎用的で便利なデータ構造が利用できない

1番目、2番目は純粋なデメリットとなっていて、1番目は、注意深くコーディングするしかなく、2番目は自前実装で補う必要があります。

一方、3番目については場合によってはデメリットにはなりません。理由は、たとえばstd::vectorのようなコンテナは非常に便利ですが、メモリ確保の仕組みを理解していないと必要以上のリソースを消費する可能性があります。

そのため、ゲームエンジン開発ではSTLコンテナを使わず、独自の軽量コンテナを実装するケースも少なくありません。最小限の機能に絞ればC言語での実装も十分可能であり、大きなデメリットとはならないでしょう。さらに、自前実装することで、データ構造、メモリ管理の仕組みを学ぶことができるという副次的な効果もあります。

以上の背景から今回はC言語を使用して開発していくことにします。

### ビルドツールについて

今回のゲームエンジン開発では、ビルドツールとして、makefileを使用したGNU makeと、シェルスクリプトのみを使用します。

一般的には CMake を使うケースが多いと思いますが、本連載では以下の理由から採用しません。

- **習得コストが高い**
  CMakeLists.txtの記述はライブラリごとに固有の方法が必要になる場合があり、マルチプラットフォーム対応やビルド条件の設定も複雑になりがちです。
- **バージョン依存のリスク**
  CMake自体や外部ライブラリのバージョン差異によって、ビルドが失敗する可能性があります。

makefile にも基本的な文法の理解は必要ですが、ライブラリごとに異なる書き方を覚える必要はありません。一度雛形を作ってしまえばプロジェクト間で容易に流用できますし、後のメンテナンスも CMakeLists.txt に比べてシンプルです。

### ライブラリについて

本連載で扱うゲームエンジンでは、マルチプラットフォーム対応を簡便に行うためにGLFWを使用します。

想定しているプラットフォームはLinux / macOS / FreeBSDで、Windows については未定です。
これらの環境ごとにイベント管理やウィンドウ生成を一から実装するのは非常に大きな労力となります。

本連載の主眼は、OpenGLを用いたレンダリングや、マテリアルなどのリソース管理、形状データのジオメトリ管理の方法を学ぶことにあります。そのため、GLFWを利用してOS依存の処理を抽象化することで、学習の焦点を本来の目的に集中できるようにします。

以上が今回開発するゲームエンジンについての開発方針の説明です。ここからは具体的にゲームエンジンの実装を進めていきます。

## Step1実装解説

Step1では、「実行基盤とメモリ管理レイヤの初期化」を行っていきます。

### Step1_1: アプリケーション土台作り

一番最初にすべきことは、とりあえずビルドし、実行できる環境を整えることです。このために、最小限のエントリーポイントと、ビルドシステムを作っていきます。さらに、今回はVSCodeを使用して開発していくので、ビルドシステムとワークスペース設定も行います。

[アプリケーション土台作り](https://zenn.dev/chocolate_pie24/books/2d_rendering/viewer/step1_1_application_base)

### Step1_2: アプリケーションレイヤーの追加

「アプリケーション土台作り」では、エントリーポイントとなるmain関数を作成し、実行する環境を整えました。次は、今後開発していくことになる様々なサブシステムのオーケストレーションを行うためのアプリケーションレイヤーを作成していきます。この段階を踏むことで、サブシステム実装、動作確認を適切な場所で行なっていくことができます。

[アプリケーションレイヤーの追加](https://zenn.dev/chocolate_pie24/books/2d_rendering/viewer/step1_2_application_layer)

### Step1_3: ベースレイヤーの追加

ここまでで、これから開発していく各機能をインストールする場所を作ることができました。次は、各サブシステムの開発に使用するためのユーティリティ機能を詰め込むベースレイヤーを作成していきます。

[ベースレイヤーの追加](https://zenn.dev/chocolate_pie24/books/2d_rendering/viewer/step1_3_base_layer)

### Step1_4: core/memoryレイヤーの追加(linear_allocator)

ここからは具体的な機能の開発に移っていきます。まずは、これから開発していく各機能に対してメモリリソースを割り当てるためのリニアアロケータを作成します。

[core/memoryレイヤーの追加(linear_allocator)](https://zenn.dev/chocolate_pie24/books/2d_rendering/viewer/step1_4_core_memory_linear_allocator)

### Step1_5: core/memoryレイヤーの追加(memory_system)

リニアアロケータの作成により、サブシステムを実装し、初期化し、実行する準備が整いました。次は、メモリリソースの管理をするためのメモリトラッキングシステムを作成します。

[core/memoryレイヤーの追加(memory_system)](https://zenn.dev/chocolate_pie24/books/2d_rendering/viewer/step1_5_core_memory_system)

### Step1_6: Doxygenドキュメンテーション

以上が「Step1_1: 実行基盤とメモリ管理レイヤの初期化」の開発内容になります。ここで、これまで作成した成果物のドキュメントを整理するため、Doxygen環境をセットアップします。

[Doxygenドキュメンテーション](https://zenn.dev/chocolate_pie24/books/2d_rendering/viewer/step1_6_doxygen)

## まとめ

以上で「Step1_1: 実行基盤とメモリ管理レイヤの初期化」は完成となります。記事の中ではdoxygenのコメントやテストコードは省いています。全てのコードは、[リポジトリ](https://github.com/chocolate-pie24/gl_choco_engine)に公開しています。ここまでの成果物には、v0.1.0-step1のタグをつけています。

次回はGLFWを使用してウィンドウを生成する機能を開発していきます。ここまで読んでいただき、ありがとうございました。
